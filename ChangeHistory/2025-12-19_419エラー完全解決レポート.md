# 419 Page Expired エラー 完全解決レポート

**作成日**: 2025年12月19日  
**問題発生期間**: 2025年12月18日〜19日  
**ステータス**: ✅ 完全解決

---

## 📋 目次

1. [問題の概要](#問題の概要)
2. [症状の詳細](#症状の詳細)
3. [根本原因の分析](#根本原因の分析)
4. [解決策の詳細](#解決策の詳細)
5. [修正ファイル一覧](#修正ファイル一覧)
6. [検証結果](#検証結果)
7. [技術的な補足](#技術的な補足)

---

## 問題の概要

### 発生した問題

Laravel + Inertia.js + Vue.js アプリケーションにおいて、特定の操作時に **100%の確率で419 "Page Expired" エラー**が発生していた。

### 影響を受けた機能

| 機能                 | 症状              |
| -------------------- | ----------------- |
| 練習問題の終了ボタン | 押下時に419エラー |
| 管理者ログアウト     | 実行時に419エラー |
| ユーザーログアウト   | 実行時に419エラー |
| 本番試験のパート完了 | 送信時に419エラー |

### 特徴的な挙動

- **ページリロード後は正常動作** → セッション/Cookie関連の問題を示唆
- **初回アクセス時のみ失敗** → 初期化タイミングの問題
- **Playwrightテストで100%再現** → 確実に再現可能な問題

---

## 症状の詳細

### ブラウザでの表示

```
419 | Page Expired
```

### Laravelログでの発見

```log
Session ensured {"session_id":"cMgGGK6SiH6jNxpBos2zgBQVsrS8XyTjAZuWxTH6"...}
Session ensured {"session_id":"UGZ6TTqh9LzMXs3VHTIUzgJZysCD8gSWR5kRRGNY"...}
Session ensured {"session_id":"ABC123xyz..."...}
```

**問題点**: リクエストごとに**異なるセッションID**が生成されていた。これはセッションCookieがブラウザからサーバーへ正しく送信されていないことを示していた。

### CSRFトークン検証の失敗フロー

```
1. ユーザーがページを開く
2. サーバーがセッションAを作成、CSRFトークンAを発行
3. ユーザーがフォームを送信
4. Cookieが正しく送信されない
5. サーバーが新しいセッションBを作成、CSRFトークンBを発行
6. 送信されたトークンA ≠ セッションBのトークンB
7. → 419 Page Expired エラー発生
```

---

## 根本原因の分析

### 原因1: セッションドライバーの設定問題

**ファイル**: `.env`

```env
# 問題のあった設定
SESSION_DRIVER=database
SESSION_CONNECTION=default
```

**問題点**: `database`ドライバーで`SESSION_CONNECTION=default`が正しく解決されず、「Database connection [default] not configured」エラーが内部的に発生していた。

---

### 原因2: fetch APIのcredentials設定

**ファイル**: `resources/js/app.ts`, `resources/js/Pages/Part.vue`

```typescript
// 問題のあった設定
credentials: "same-origin";
```

**問題点**: Dockerコンテナ環境では`localhost`と`127.0.0.1`が異なるオリジンとして扱われる場合があり、`same-origin`ではCookieが送信されないケースがあった。

---

### 原因3: CSRFトークンがフロントエンドに共有されていない

**ファイル**: `app/Http/Middleware/HandleInertiaRequests.php`

```php
// share()メソッドの戻り値にcsrf_tokenが含まれていなかった
public function share(Request $request): array
{
    return array_merge(parent::share($request), [
        'auth' => [...],
        'flash' => [...],
        // csrf_token が欠落していた！
    ]);
}
```

---

### 原因4: VerifyCsrfTokenの除外設定

**ファイル**: `app/Http/Middleware/VerifyCsrfToken.php`

```php
// 以前の設定 - CSRF検証が完全に無効化されていた
protected $except = [
    '/practice/complete',
    '/guest/practice/complete',
    '/exam/complete-part',
    '/guest/exam/complete-part',
];
```

**問題点**: 除外設定があったため、正しいCSRF実装の問題が隠蔽されていた。除外を削除した時点で問題が顕在化。

---

### 原因5: フロントエンドフォームにCSRFトークンが含まれていない

**ファイル**: `resources/js/Pages/Practice.vue`, `resources/js/Pages/Part.vue`

```typescript
// フォーム初期化時に_tokenフィールドがなかった
const form = useForm({
    answers: [],
    // _token が欠落！
});
```

---

### 原因6: ログアウト処理がInertia routerを使用していない

**ファイル**: `resources/js/Pages/Admin/Dashboard.vue`

```typescript
// 手動でフォームを作成していた（CSRFトークンが正しく付与されない）
const logout = () => {
    const form = document.createElement("form");
    form.method = "POST";
    // ...
};
```

---

## 解決策の詳細

### 修正1: SESSION_DRIVERをredisに変更

**ファイル**: `.env`

```env
# 変更前
SESSION_DRIVER=database

# 変更後
SESSION_DRIVER=redis
```

**効果**: Redisは設定がシンプルで、接続問題が発生しにくい。

---

### 修正2: credentials設定を"include"に変更

**ファイル**: `resources/js/app.ts`

```typescript
// 変更前
const response = await fetch("/sanctum/csrf-cookie", {
    method: "GET",
    credentials: "same-origin",
});

// 変更後
const response = await fetch("/sanctum/csrf-cookie", {
    method: "GET",
    credentials: "include",
});
```

**ファイル**: `resources/js/Pages/Part.vue`

```typescript
// 変更前
const response = await fetch("/exam/save-answer", {
    method: "POST",
    credentials: "same-origin",
    // ...
});

// 変更後
const response = await fetch("/exam/save-answer", {
    method: "POST",
    credentials: "include",
    // ...
});
```

**効果**: クロスオリジンリクエストでもCookieが確実に送信される。

---

### 修正3: HandleInertiaRequestsでCSRFトークンを共有

**ファイル**: `app/Http/Middleware/HandleInertiaRequests.php`

```php
public function share(Request $request): array
{
    return array_merge(parent::share($request), [
        'auth' => [...],
        'flash' => [...],
        'csrf_token' => csrf_token(),  // ← 追加
    ]);
}
```

**効果**: フロントエンドが`page.props.csrf_token`でトークンにアクセス可能になる。

---

### 修正4: VerifyCsrfTokenの除外設定を削除

**ファイル**: `app/Http/Middleware/VerifyCsrfToken.php`

```php
// 変更前
protected $except = [
    '/practice/complete',
    '/guest/practice/complete',
    // ...
];

// 変更後
protected $except = [];
```

**効果**: すべてのPOSTリクエストでCSRF検証が有効になる。

---

### 修正5: フロントエンドフォームにCSRFトークンを追加

**ファイル**: `resources/js/Pages/Practice.vue`

```typescript
// フォーム初期化
const form = useForm({
    answers: [],
    _token: page.props.csrf_token || "", // ← 追加
});

// 送信前にトークンを再取得
const completePractice = () => {
    const csrfToken =
        document.querySelector('meta[name="csrf-token"]')?.getAttribute("content") || "";
    form._token = csrfToken;
    form.post(route("practice.complete"));
};
```

**ファイル**: `resources/js/Pages/Part.vue`

```typescript
const form = useForm({
    part_id: props.part.id,
    answers: [],
    _token: (page.props as any).csrf_token || "", // ← 追加
});
```

---

### 修正6: ログアウト処理をInertia routerに変更

**ファイル**: `resources/js/Pages/Admin/Dashboard.vue`

```typescript
import { router } from "@inertiajs/vue3";

// 変更前（手動フォーム作成）
const logout = () => {
    const form = document.createElement("form");
    // ...
};

// 変更後（Inertia router使用）
const logout = () => {
    router.post(
        route("admin.logout"),
        {},
        {
            preserveState: false,
            preserveScroll: false,
        }
    );
};
```

**効果**: Inertia routerはAxiosを内部で使用し、自動的にCSRFトークンを付与する。

---

### 修正7: EnsureSessionStartedミドルウェアの簡素化

**ファイル**: `app/Http/Middleware/EnsureSessionStarted.php`

```php
public function handle(Request $request, Closure $next): Response
{
    // セッションが開始されていなければ開始
    if (!$request->hasSession()) {
        $request->setLaravelSession(app('session.store'));
    }

    if (!$request->session()->isStarted()) {
        $request->session()->start();
    }

    // CSRFトークンを確実にセッションに保存（存在しない場合のみ）
    if (!$request->session()->has('_token')) {
        $request->session()->regenerateToken();
    }

    return $next($request);
}
```

**効果**: 不要なセッション再生成を防止。

---

### 修正8: Playwrightテストフィクスチャの修正

**ファイル**: `e2e/fixtures/auth.fixture.ts`

```typescript
// ログイン後にCSRF Cookieを再取得（セッションが変わるため）
await page.goto("/sanctum/csrf-cookie");
await page.waitForTimeout(300);
await page.goto("/admin/dashboard");
```

**効果**: ログインでセッションが再生成された後、新しいCSRFトークンを取得。

---

## 修正ファイル一覧

| ファイル                                            | 修正内容                                       |
| --------------------------------------------------- | ---------------------------------------------- |
| `.env`                                              | SESSION_DRIVER を redis に変更                 |
| `resources/js/app.ts`                               | credentials を "include" に変更                |
| `resources/js/Pages/Part.vue`                       | credentials を "include" に変更、\_token追加   |
| `resources/js/Pages/Practice.vue`                   | \_token フィールド追加、トークン再取得ロジック |
| `resources/js/Pages/PracticeExplanation.vue`        | CSRFトークン追加                               |
| `resources/js/Pages/Admin/Dashboard.vue`            | Inertia router使用に変更                       |
| `resources/js/Components/ResponsiveUserProfile.vue` | router.post使用に変更                          |
| `resources/js/Components/DropdownLink.vue`          | method, as props追加                           |
| `resources/js/Components/Dropdown.vue`              | ハードコードstyle削除                          |
| `app/Http/Middleware/HandleInertiaRequests.php`     | csrf_token 共有追加                            |
| `app/Http/Middleware/VerifyCsrfToken.php`           | $except を空配列に                             |
| `app/Http/Middleware/EnsureSessionStarted.php`      | ロジック簡素化                                 |
| `app/Http/Controllers/PracticeController.php`       | \_token バリデーション追加                     |
| `app/Http/Controllers/ExamController.php`           | \_token バリデーション追加                     |
| `e2e/fixtures/auth.fixture.ts`                      | CSRF Cookie再取得追加                          |
| `e2e/helpers/auth.helper.ts`                        | ログイン後のCSRF取得追加                       |

---

## 検証結果

### Playwrightテスト結果

```bash
npx playwright test --grep "ログアウト|練習を完了" --reporter=list
```

```
✓ 認証機能 › ログアウトが正常に動作する (8.7s)
✓ 管理者機能 › ログアウトできる (7.8s)
✓ 練習問題機能 › 練習を完了できる（419エラーデバッグ付き） (8.8s)

3 passed (10.3s)
```

### ログ検証

- ✅ `storage/logs/laravel.log` に419エラーなし
- ✅ "token mismatch" エラーなし
- ✅ セッションIDが一貫して維持される
- ✅ CSRFトークンが正常に生成・検証される

---

## 技術的な補足

### credentials設定の違い

| 設定          | 動作                                     |
| ------------- | ---------------------------------------- |
| `same-origin` | 同一オリジンのリクエストのみCookieを送信 |
| `include`     | クロスオリジンリクエストでもCookieを送信 |

**推奨**: Docker環境では`include`を使用する。

---

### CSRFトークンフロー（修正後）

```
┌─────────────────────────────────────────────────────────────┐
│                    正常なCSRFトークンフロー                    │
└─────────────────────────────────────────────────────────────┘

1. セッション開始
   └─> csrf_token() 生成、セッションに保存

2. HandleInertiaRequests.share()
   └─> 'csrf_token' => csrf_token() をpropsに追加

3. フロントエンド受信
   └─> page.props.csrf_token でアクセス可能

4. フォーム初期化
   └─> _token: page.props.csrf_token を含める

5. 送信前処理
   └─> meta[name="csrf-token"] から最新トークン取得
   └─> form._token に設定

6. form.post() 実行
   └─> _token がリクエストボディに含まれる

7. VerifyCsrfToken ミドルウェア
   └─> リクエストの _token とセッションの _token を比較

8. コントローラーバリデーション
   └─> '_token' => 'required|string' で検証

9. リクエスト成功 ✓
```

---

### デバッグ用ログ（将来の問題調査用）

`app/Http/Middleware/VerifyCsrfToken.php` に追加されたデバッグログ：

```php
protected function tokensMatch($request)
{
    \Log::debug('CSRF Token Check', [
        'body_token' => $bodyToken ? substr($bodyToken, 0, 10) . '...' : null,
        'header_token' => $headerToken ? substr($headerToken, 0, 10) . '...' : null,
        'session_token' => $sessionToken ? substr($sessionToken, 0, 10) . '...' : null,
        'session_id' => $request->session()->getId(),
    ]);
    return parent::tokensMatch($request);
}
```

---

## 関連ドキュメント

- [CSRF_TOKEN_FIXES_SUMMARY.md](CSRF_TOKEN_FIXES_SUMMARY.md)
- [CSRF_TOKEN_FIXES_PHASE2.md](CSRF_TOKEN_FIXES_PHASE2.md)
- [2025-12-18-CSRF-Fix-Implementation.md](2025-12-18-CSRF-Fix-Implementation.md)
- [2025-12-18-CSRF-Root-Cause.md](2025-12-18-CSRF-Root-Cause.md)

---

## まとめ

419 Page Expiredエラーは、**複数の原因が同時に存在**していたために発生していた：

1. **セッション管理の問題** - ドライバー設定とCookie送信
2. **トークン共有の欠如** - バックエンドからフロントエンドへの伝達
3. **フォーム実装の不備** - トークンフィールドの欠落
4. **ログアウト処理の問題** - Inertia routerの未使用

これらすべてを**同時に修正**することで、問題が完全に解決された。

**教訓**: CSRFトークンの問題は、トークンの生成から検証までの**全フロー**を確認する必要がある。一部分だけの修正では解決しない場合がある。
